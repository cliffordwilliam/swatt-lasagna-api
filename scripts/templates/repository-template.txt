import { FilterQuery } from "@mikro-orm/core";
import { getEM } from "../../core/database/adapter";
import { <ENTITY_CLASS> } from "../entities/<DOMAIN_NAME>.entity";
import { <DOMAIN_NAME^>Filter } from "../schemas/<DOMAIN_NAME>";

export const <ENTITY_CLASS>Repository = {
  async getByIdOrFail(<DOMAIN_NAME>Id: number) {
    const em = await getEM();
    return em.findOneOrFail(<ENTITY_CLASS>, { <DOMAIN_NAME>Id });
  },

  async list(filters: <DOMAIN_NAME^>Filter) {
    const em = await getEM();
    const conditions: FilterQuery<<ENTITY_CLASS>>[] = [];

    if (filters.<ENTITY_PREFIX>Name) {
      conditions.push({ <ENTITY_PREFIX>Name: { $ilike: `%${filters.<ENTITY_PREFIX>Name}%` } });
    }

    const where: FilterQuery<<ENTITY_CLASS>> =
      filters.mode === "and" ? { $and: conditions } : { $or: conditions };

    const sortField = "<ENTITY_PREFIX>Name";

    const [entities, totalCount] = await em.findAndCount(<ENTITY_CLASS>, where, {
      limit: filters.pageSize,
      offset: (filters.page - 1) * filters.pageSize,
      orderBy: { [sortField]: filters.sortOrder },
    });

    const totalPages = Math.ceil(totalCount / filters.pageSize);

    return {
      data: entities,
      pagination: {
        page: filters.page,
        pageSize: filters.pageSize,
        totalCount,
        totalPages,
        hasNext: filters.page < totalPages,
        hasPrevious: filters.page > 1,
      },
    };
  },

  async save(<DOMAIN_NAME>: <ENTITY_CLASS>) {
    const em = await getEM();
    await em.persistAndFlush(<DOMAIN_NAME>);
    return <DOMAIN_NAME>;
  },
};

